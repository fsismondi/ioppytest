#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import logging
import traceback
import textwrap
import datetime

from ioppytest import LOG_LEVEL, LOGGER_FORMAT
from ioppytest.utils.messages import *
from ioppytest.utils.rmq_handler import RabbitMQHandler, JsonFormatter
from ioppytest.utils.tabulate import tabulate
from ioppytest.finterop_ui_adaptor.ui_tasks import (get_field_keys_from_ui_reply,
                                                    get_field_keys_from_ui_request,
                                                    get_field_value_from_ui_reply)
from ioppytest.finterop_ui_adaptor.user_help_text import *
from ioppytest.finterop_ui_adaptor import (COMPONENT_ID,
                                           STDOUT_MAX_STRING_LENGTH,
                                           STDOUT_MAX_STRING_LENGTH_KEY_COLUMN,
                                           STDOUT_MAX_STRING_LENGTH_VALUE_COLUMN,
                                           UI_TAG_BOOTSTRAPPING,
                                           UI_TAG_SETUP,
                                           UI_TAG_REPORT)

# init logging to stnd output and log files
logger = logging.getLogger("%s|%s" % (COMPONENT_ID, 'msg_translator'))
logger.setLevel(LOG_LEVEL)

# AMQP log handler with f-interop's json formatter
rabbitmq_handler = RabbitMQHandler(AMQP_URL, COMPONENT_ID)
json_formatter = JsonFormatter()
rabbitmq_handler.setFormatter(json_formatter)
logger.addHandler(rabbitmq_handler)


@property
def NotImplementedField(self):
    raise NotImplementedError


def translate_ioppytest_description_format_to_tabulate(ls):
    """
        we get stuff like:

        as output we need:

    """
    # fixme change ioppytest format to meet tabulates requirements, their fromat for describing tables makes more sense!
    ret = []
    for item in ls:
        if type(item) is str:
            # textwrap puts <\n> per each X chars
            ret.append([textwrap.fill(item, width=STDOUT_MAX_STRING_LENGTH_KEY_COLUMN)])
        elif type(item) is list:
            for subitem in item:
                if type(subitem) is str:
                    # textwrap puts <\n> per each X chars
                    ret.append([' ', textwrap.fill(subitem,
                                                   width=STDOUT_MAX_STRING_LENGTH_VALUE_COLUMN)])
                else:
                    ret.append([' ', subitem])
        else:
            logger.warning("Got unexpected table format %s" % type(item))

    logger.debug("converted table: %s" % ret)

    return ret


def list_to_str(ls):
    """
    flattens a nested list up to two levels of depth

    :param ls: the list, supports str also
    :return: single string with all the items inside the list
    """

    ret = ''

    if ls is None:
        return 'None'

    if type(ls) is str:
        return ls

    try:
        for l in ls:
            if l and isinstance(l, list):
                for sub_l in l:
                    if sub_l and not isinstance(sub_l, list):
                        ret += str(sub_l) + '\n'
                    else:
                        # I truncate in the second level
                        pass
            else:
                ret += str(l) + '\n'

    except TypeError as e:
        logger.error(e)
        return str(ls)

    return ret


class GenericBidirectonalTranslator(object):
    """
    This class acts as a transformation filter between TT messages and UI messages, and as a UI messages
    creator for certain generic session user actions.

                        _______________________
                        |                      |
    UI from/to messages |                      |   TT from/to messages
    <----------------   |   BiDict translator  |    <----------------
    ---------------->   |                      |    ---------------->
                        |______________________|


    This component is stateful, it saves all pending request already sent to UI,
    so then UI replies can be translated into TT chained actions.
    It also preserves some states related to the testcase and step under execution.

    --------------------------------------------------------------------------
    for simple UI message display like the one generated by <testcase verdict>
    --------------------------------------------------------------------------
     UI            Translator          TT
     |                |                |
     |                |   TT_x         |
     |                |<----------------
     |                |                |
     |       UI_x     |                |
     <----------------|                |
     |                |                |


    -----------------------------------------------------------------
     for chained actions like the one triggered by <stimuli execute>
    -----------------------------------------------------------------
     UI            Translator          TT
     |                |                |
     |                |   TT_x         |
     |                |<----------------
     |                |                |
     |      (prepare UI_x request)     |
     |     (save (UI_x,TT_x) request)  |
     |                |                |
     |       UI_x     |                |
     <----------------|                |
     |                |                |
     |  UI_y reply    |                |
     ---------------->|                |
     |                |                |
     |   (prepare TT_y chained message |
     |      using (UI_y,UI_x,TT_x))    |
     |                |                |
     |  (drop UI_y,UI_x,TT_x entry)    |
     |                |                |
     |                |   TT_y         |
     |                |---------------->
     |                |                |
     |                |                |
     |                |                |


    Request format:
        MsgUiRequestConfirmationButton(fields = [
            {
                'value': True,
                'type': 'button',
                'name': 'start_test_suite'
            }
            (...)
        ]

        Reply format:
        Message(fields = [
            {
                'start_test_suite': True
            },
            (..)
        ]

    """

    IUT_ROLES = NotImplementedField

    def __init__(self):

        logger.info("Starting UI message tanslator..")

        self._current_tc = None
        self._current_step = None
        self._report = None
        self._pending_responses = {}
        self.specialized_visualization = {

            # test suite /test cases /test steps messages
            MsgTestingToolReady: self._echo_message_highlighted_description,
            MsgTestCaseFinished: self._echo_message_highlighted_description,
            MsgTestCaseReady: self._echo_testcase_ready,
            MsgStepStimuliExecute: self._echo_message_steps,
            MsgStepStimuliExecuted: self._echo_message_highlighted_description,
            MsgStepVerifyExecute: self._echo_message_steps,
            MsgStepVerifyExecuted: self._echo_message_highlighted_description,
            MsgConfigurationExecute: self._echo_testcase_configure,

            # info
            MsgTestSuiteGetTestCasesReply: self._echo_testcases_list,
            MsgTestingToolConfigured: self._echo_testing_tool_configured,

            # verdicts and results
            MsgTestCaseVerdict: self._echo_testcase_verdict,
            MsgTestSuiteReport: self._echo_test_suite_results,

            # important messages
            MsgTestingToolTerminate: self._echo_message_highlighted_description,

            # agents data messages and dissected messages
            MsgPacketInjectRaw: self._echo_packet_raw,
            MsgPacketSniffedRaw: self._echo_packet_raw,
            MsgDissectionAutoDissect: self._echo_packet_dissected,

            # tagged as debugging
            MsgSessionConfiguration: self._echo_as_debug_messages,
            MsgSessionLog: self._echo_as_debug_messages,
            MsgTestingToolComponentReady: self._echo_as_debug_messages,
            MsgAgentConfigured: self._echo_as_debug_messages,
            MsgAgentTunStart: self._echo_as_debug_messages,
            MsgAgentTunStarted: self._echo_as_debug_messages,

            # barely important enough to not be in the debugging
            MsgTestingToolComponentShutdown: self._echo_message_description_and_component,
            MsgTestCaseStarted: self._echo_message_highlighted_description,
            MsgTestCaseStart: self._echo_message_highlighted_description,
            MsgTestSuiteStarted: self._echo_message_highlighted_description,
            MsgTestSuiteStart: self._echo_message_highlighted_description,
            MsgConfigurationExecuted: self._echo_message_highlighted_description,
        }

        # init:
        # 1. receive Msg TT confiured -> action _ui_request_env_config
        # 2. received OK for ENV config -> request agent config
        # 3. received OK for agen conf -> _ui_request_testsuite_start

        self.tt_to_ui_message_translation = {
            MsgTestingToolConfigured: self._ui_request_testsuite_start,
            MsgTestCaseReady: self._ui_request_testcase_start,
            MsgStepStimuliExecute: self._ui_request_step_stimuli_executed,
            MsgStepVerifyExecute: self._ui_request_step_verification,
        }

        self.ui_to_tt_message_translation = {
            'ts_start': self._tt_message_testsuite_start,
            'ts_abort': self._tt_message_testsuite_abort,
            'tc_start': self._tt_message_testcase_start,
            'tc_restart': self._tt_message_testcase_restart,
            'tc_skip': self._tt_message_testcase_skip,
            # 'tc_list': self._handle_get_testcase_list,
            # 'tc_select': self._handle_testcase_select,
            'verify_executed': self._tt_message_step_verify_executed,
            'stimuli_executed': self._tt_message_step_stimuli_executed,
        }

    def bootstrap(self, amqp_connector):
        """
        Bootstrap is executed before the main thread enters the main loop.
        During bootstrap phase the class gets to update all its configuration by asking the user directly
        (or to GUI services).

        Only during bootstrap Translators are allowed to send and receive messages directly, this is why
        bootstrap receives amqp_connector as param.
        Every child class should implement this, at least for printing a Hello World message in GUI!

        only the following API calls should be used from bootstrap method:
            amqp_connector.synch_request(self, request, timeout)
            amqp_connector.publish_ui_display(self, message: Message, user_id=None, level=None)

        """

        # for specialized request, displays etc for each type of test suite
        self._bootstrap(amqp_connector)

    def _bootstrap(self, amqp_connector):
        """
        to be implemented by child class  (if no bootstrap need then just "pass"
        """

        raise NotImplementedError()

    def get_iut_roles(self):
        return self.IUT_ROLES

    def update_state(self, message):
        """
            Updates message factory states, every received message needs to be passed to this method
        """
        try:
            self._current_tc = message.testcase_id
        except AttributeError:
            pass

        try:
            self._current_step = message.step_id
        except AttributeError:
            pass

        # print states table
        status_table = list()
        status_table.append(['current testcase id', 'current test step id'])
        status_table.append([self._current_tc, self._current_step])
        logger.debug(tabulate(status_table, tablefmt="grid", headers="firstrow"))

    def tag_message(self, msg):
        """
            Updates message tags of message before being sent to UI. Every message to UI needs to be passed to this
            method before being published
        """
        if msg and not msg.tags:

            if self._current_tc:
                msg.tags = {"testcase": self._current_tc}

            else:
                msg.tags = {"logs": ""}

        return msg

    def get_ui_request_action_message(self, message_from_tt: Message):
        """
        translates:  (message_from_tt) -> a UI request
        :returns Message for UI or None
        """

        try:
            action = self.tt_to_ui_message_translation[type(message_from_tt)]
            ui_request_message = action(message_from_tt)
            return ui_request_message

        except KeyError:
            logger.debug("Action %s not found in tt_to_ui translation table" % repr(message_from_tt))
            return None

    def translate_ui_to_tt_message(self, reply_received_from_ui):
        """
        translates:  (ui reply , pending responses info) -> a TT response
        :returns Message for TT or None

        """

        # get table entry inserted on UI request
        ui_requested_fields, ui_request_message, tt_message = self.pop_pending_response(
            reply_received_from_ui.correlation_id
        )

        # what happens if user reply has to fields? this still is not used/nor forseen to be used by this TT
        response_fields_names = get_field_keys_from_ui_reply(reply_received_from_ui)
        if len(response_fields_names) > 1:
            raise Exception("UI returned a reply with two or more fields : %s " % reply_received_from_ui.fields)

        # get that one reply field (e.g. ts_start)
        user_input_action = response_fields_names[0]

        # assert the reply field sent by UI matches the info in the pending response list
        assert user_input_action in ui_requested_fields, "%s not in %s" % (user_input_action, ui_requested_fields)

        # get the value of the field from reply_received_from_ui
        user_input_value = get_field_value_from_ui_reply(reply_received_from_ui, user_input_action)

        try:
            # get handler based on the ui response action (e.g. ts_start, tc_skip , etc)
            ui_to_tt_message_handler = self.ui_to_tt_message_translation[user_input_action]

            # run handler with user reply value + tt message that triggered the UI request in the first place
            message_for_tt = ui_to_tt_message_handler(user_input_value, tt_message)
        except KeyError:
            logger.debug("No chained action to reply %s" % repr(reply_received_from_ui)[:STDOUT_MAX_STRING_LENGTH])
            return None

        logger.debug("UI reply :%s translated into TT message %s"
                     % (
                         repr(reply_received_from_ui),
                         repr(message_for_tt)
                     ))
        return message_for_tt

    def transform_message_to_ui_markdown_display(self, message: Message):
        msg_ret = None

        # search for specialized visualization, returns fields
        if type(message) in self.specialized_visualization:
            specialized_visualization = self.specialized_visualization[type(message)]
            msg_ret = specialized_visualization(message)

        # generic message visualization (message as a table)
        else:
            logger.info("No specialized UI visualisation for message type: %s" % str(type(message)))
            msg_ret = self._echo_message_as_table(message)

        msg_ret = self.tag_message(msg_ret)
        return msg_ret

    @classmethod
    def transform_string_to_ui_markdown_display(cls, text=None):

        msg = MsgUiDisplayMarkdownText()

        fields = [
            {
                'type': 'p',
                'value': text
            }
        ]

        msg.fields = fields

        return msg

    def add_pending_response(self, corr_id, ui_requested_field_name_list: list, ui_request_message,
                             tt_request_originator):
        """
        Adds pending response to table. Note that this overwrites entries with same corr_id
        :param corr_id: Correlation id of request/reply
        :param ui_requested_field_name_list: The list of fields names in the UI request
        :param ui_request_message: Message request sent to UI
        :param ui_request_message: Message (from TT) originating the request in the first place
        :return:

        """
        if corr_id in self._pending_responses:
            logger.warning(
                "Overwriting pending response table entry, adding corr id %s | entry %s" %
                (
                    corr_id,
                    self._pending_responses[corr_id]
                )
            )

        self._pending_responses[corr_id] = ui_requested_field_name_list, ui_request_message, tt_request_originator

        logger.info(
            "Updated pending response table,adding \n\tcorr id %s \n\tentry %s"
            % (
                corr_id,
                self._pending_responses[corr_id]
            )
        )

        self.print_table_of_pending_responses()

    def print_table_of_pending_responses(self):
        # table's header
        table = [
            ['Correlation Id',
             'Field name request (list)',
             'Message sent to UI',
             'Message from TT triggering request']
        ]
        for key, value in self._pending_responses.items():
            entry = [
                key,
                value[0],
                repr(type(value[1])),
                repr(type(value[2])),
            ]
            table.append(entry)

        logger.info(tabulate(table, tablefmt="grid", headers="firstrow"))

    def get_pending_messages_correlation_id(self):
        return list(self._pending_responses.keys())

    def pop_pending_response(self, correlation_id):
        ret = None

        if correlation_id in self._pending_responses:
            ret = self._pending_responses.pop(correlation_id, None)

        logger.debug("Updated pending response table")
        self.print_table_of_pending_responses()
        return ret

    def is_pending_response(self, message):
        try:
            return message.correlation_id in self._pending_responses
        except AttributeError:
            return False

    # # # # # # #  TT -> UI translation to be implemented BY CHILD CLASS # # # # # # #

    def _ui_request_testsuite_start(self, message_from_tt):
        raise NotImplementedError()

    def _ui_request_testcase_start(self, message_from_tt):
        raise NotImplementedError()

    def _ui_request_step_verification(self, message_from_tt):
        raise NotImplementedError()

    def _ui_request_step_stimuli_executed(self, message_from_tt):
        raise NotImplementedError()

    # # # # # # #  UI -> TT translation to be implemented BY CHILD CLASS # # # # # # #

    def _tt_message_testsuite_start(self, user_input, origin_tt_message=None):
        raise NotImplementedError()

    def _tt_message_testsuite_abort(self, user_input, origin_tt_message=None):
        raise NotImplementedError()

    def _tt_message_testcase_start(self, user_input, origin_tt_message=None):
        raise NotImplementedError()

    def _tt_message_testcase_restart(self, user_input, origin_tt_message=None):
        raise NotImplementedError()

    def _tt_message_testcase_skip(self, user_input, origin_tt_message=None):
        raise NotImplementedError()

    def _tt_message_step_verify_executed(self, user_input, origin_tt_message=None):
        raise NotImplementedError()

    def _tt_message_step_stimuli_executed(self, user_input, origin_tt_message=None):
        raise NotImplementedError()

    # # # # # # # # # # # GENERIC MESSAGE UI VISUALISATION # # # # # # # # # # # # # # #

    def _echo_message_as_table(self, message):

        msg_ret = MsgUiDisplayMarkdownText()

        # convert message to table
        d = message.to_dict()
        table = []
        for key, value in d.items():
            if type(value) is list:
                flatten_value = list_to_str(value)
                flatten_value = textwrap.fill(flatten_value, width=STDOUT_MAX_STRING_LENGTH_VALUE_COLUMN)
                temp = [key, flatten_value]
            else:
                temp = [key, str(value)]
            table.append(temp)

        # prepare fields
        msg_ret.fields = [{
            'type': 'p',
            'value': tabulate(table)
        }]

        return msg_ret

    # # # # # # # # # # # PERSONALIZED MESSAGES VISUALISATION # # # # # # # # # # # # # # #
    def _generate_ui_fields_for_testcase_report(self, tc_report: dict):
        """
        used to display in UI MsgTestCaseVerdict and MsgTestSuiteReports messages
        """
        try:
            partial_verdict = tc_report.pop('partial_verdicts')
        except KeyError:
            partial_verdict = None
            logger.warning("No partial_verdicts for TC: %s" % tc_report['testcase_id'])

        ui_fields = []
        table_result = []
        display_color = 'warning'  # 'warning' is yellow, 'highlighted' is green, and 'error' is red

        for key, value in tc_report.items():

            if type(value) is list:
                # flatten lists and fill in table to display
                flatten_value = list_to_str(value)
                flatten_value = textwrap.fill(flatten_value, width=STDOUT_MAX_STRING_LENGTH_VALUE_COLUMN)
                temp = [key, flatten_value]
            else:
                # fill in table to display
                temp = [key, value]
                # try to set the color of the box using the verdict
                if 'verdict' in key and 'pass' in value:
                    display_color = 'highlighted'
                elif 'verdict' in key and value in ['fail', 'error', 'none']:
                    display_color = 'error'

            table_result.append(temp)

        ui_fields.append(
            {
                'type': 'p',
                'value': tabulate(table_result)
            }
        )
        if partial_verdict:
            table_partial_verdicts = []
            frames = []
            table_partial_verdicts.append(('Step ID', 'Partial verdict', 'Description'))
            for item in partial_verdict:
                try:
                    assert type(item) is list
                    cell_1 = item.pop(0)
                    cell_2 = item.pop(0)
                    cell_3 = list_to_str(item)
                    cell_3 = textwrap.fill(cell_3, width=STDOUT_MAX_STRING_LENGTH_VALUE_COLUMN)
                    if 'Frame' in list_to_str(item):
                        frames.append(item)
                    table_partial_verdicts.append((cell_1, cell_2, cell_3))
                except Exception as e:
                    logger.error(e)
                    logger.error(traceback.format_exc())
                    break

            ui_fields.append(
                {
                    'type': 'p',
                    'value': "Checks:"
                }
            )
            ui_fields.append(
                {
                    'type': 'p',
                    'value': "%s" % tabulate(frames)
                }
            )

            ui_fields.append(
                {
                    'type': 'p',
                    'value': tabulate(table_partial_verdicts, headers="firstrow")
                }
            )

        return tc_report['testcase_id'], display_color, ui_fields

    def _echo_testcase_verdict(self, message):
        verdict = message.to_dict()
        # fixme find a way of managing the "printable" fields, in a generic way
        verdict.pop('_api_version')  # we dont want to display the api version in UI

        tc_id, display_color, ui_fields = self._generate_ui_fields_for_testcase_report(verdict)

        return MsgUiDisplayMarkdownText(
            title="Verdict on TEST CASE: %s" % tc_id,
            level=display_color,
            fields=ui_fields,
        )

    def _echo_test_suite_results(self, message):
        """
        format of the message's body:
        {
        "tc_results": [
            {
                "testcase_id": "TD_COAP_CORE_01",
                "verdict": "pass",
                "description": "No interoperability error was detected,",
                "partial_verdicts":
                    [
                        ["TD_COAP_CORE_01_step_02", None, "CHECK postponed", ""],
                        ["TD_COAP_CORE_01_step_03", None, "CHECK postponed", ""],
                        ["TD_COAP_CORE_01_step_04", "pass",
                         "VERIFY step: User informed that the information was displayed "
                         "correclty on his/her IUT",
                         ""],
                        ["CHECK_1_post_mortem_analysis", "pass",
                         "<Frame   3: [bbbb::1 -> bbbb::2] CoAP [CON 43211] GET /test> Match: "
                         "CoAP(type=0, code=1)"],
                        ["CHECK_2_post_mortem_analysis", "pass",
                         "<Frame   4: [bbbb::2 -> bbbb::1] CoAP [ACK 43211] 2.05 Content > "
                         "Match: CoAP(code=69, mid=0xa8cb, tok=b'', pl=Not(b''))"],
                        [
                            "CHECK_3_post_mortem_analysis",
                            "pass",
                            "<Frame   4: [bbbb::2 -> bbbb::1] CoAP [ACK 43211] 2.05 Content > "
                            "Match: CoAP(opt=Opt(CoAPOptionContentFormat()))"]
                    ]
            },
            {
                "testcase_id": "TD_COAP_CORE_02",
                "verdict": "pass",
                "description": "No interoperability error was detected,",
                "partial_verdicts": [
                    ["TD_COAP_CORE_02_step_02", None, "CHECK postponed", ""],
                    ["TD_COAP_CORE_02_step_03", None, "CHECK postponed", ""],
                    ["TD_COAP_CORE_02_step_04", "pass",
                     "VERIFY step: User informed that the information was displayed correclty on his/her "
                     "IUT",
                     ""], ["CHECK_1_post_mortem_analysis", "pass",
                           "<Frame   3: [bbbb::1 -> bbbb::2] CoAP [CON 43213] DELETE /test> Match: CoAP(type=0, "
                           "code=4)"],
                    ["CHECK_2_post_mortem_analysis", "pass",
                     "<Frame   4: [bbbb::2 -> bbbb::1] CoAP [ACK 43213] 2.02 Deleted > Match: CoAP("
                     "code=66, mid=0xa8cd, tok=b'')"]]
            }
        ]
        }
        """

        fields = []
        fields_tail = []
        testcases = message.tc_results

        # add header
        summary_table = [["Testcase ID", "Verdict", "Description"]]
        display_color = 'highlighted'

        for tc_report in testcases:
            assert type(tc_report) is dict

            # add report basic info as a raw into the summary_table
            try:
                summary_table.append([tc_report['testcase_id'], tc_report['verdict'], tc_report['description']])
            except KeyError:
                logger.warning("Couldnt parse: %s" % str(tc_report))
                summary_table.append([tc_report['testcase_id'], "None", "None"])

            # to add details we put it in the fields tail which will be displayed after the summary
            tc_id, tc_verdict_color, ui_fields = self._generate_ui_fields_for_testcase_report(tc_report)

            if tc_verdict_color is 'error':
                display_color = tc_verdict_color

            fields_tail = fields_tail + [{
                'type': 'p',
                'value': '---\n---\n%s:\n' % tc_id
            }]

            if type(ui_fields) is list:
                fields_tail = fields_tail + ui_fields
            else:
                logger.error("not a list: %s" % ui_fields)

        # add summary
        fields.append({
            'type': 'p',
            'value': '%s' % (tabulate(summary_table, tablefmt="grid", headers="firstrow"))
        })

        fields.append({
            'type': 'p',
            'value': 'see details on verdicts below'
        })

        # add long line as delimiter
        fields.append({
            'type': 'p',
            'value': '-' * 70
        })

        # add tail (verdict details like checks etc..)
        fields = fields + fields_tail

        return MsgUiDisplayMarkdownText(
            title="Test suite report",
            level=display_color,
            fields=fields,
            tags=UI_TAG_REPORT,
        )

    def _echo_message_description_and_component(self, message):
        fields = [
            {
                'type': 'p',
                'value': '%s: %s' % (message.component, message.description)
            }
        ]
        return MsgUiDisplayMarkdownText(fields=fields)

    def _echo_message_highlighted_description(self, message):
        fields = [
            {
                'type': 'p',
                'value': message.description
            }
        ]

        return MsgUiDisplayMarkdownText(level='highlighted', tags={"testsuite": ""}, fields=fields)

    def _echo_message_steps(self, message):
        """
        STIMULI:

         description            Please execute step: TD_COAP_CORE_01_step_01
                                 Step description: ['Client is requested to send a GET request with', ['Type = 0(CON)', 'Code = 1(GET)']]
         target_address         coap://[bbbb::2]:5683
         _api_version           0.1.48
         node                   coap_client
         testcase_ref           http://doc.f-interop.eu/tests/TD_COAP_CORE_01
         state                  executing
         step_id                TD_COAP_CORE_01_step_01
         node_execution_mode    user_assisted
         testcase_id            TD_COAP_CORE_01
         step_type              stimuli
         node_address
         step_state             executing
         _type                  testcoordination.step.stimuli.execute
         step_info              Client is requested to send a GET request with
                                 Type = 0(CON)
                                 Code = 1(GET)

        or
        VERIFY:

         step_info              Client displays the received information
         description            Please execute step: TD_COAP_CORE_01_step_04
                                 Step description: ['Client displays the received information']
         _api_version           0.1.71
         testcase_id            TD_COAP_CORE_01
         step_id                TD_COAP_CORE_01_step_04
         node_execution_mode    user_assisted
         node_address
         node                   coap_client
         testcase_ref           http://doc.f-interop.eu/tests/TD_COAP_CORE_01
         _type                  testcoordination.step.verify.execute
         step_type              verify
         step_state             executing
         state                  executing
         response_type          bool

        """
        fields_to_translate = ['step_id', 'step_type', 'node', 'target_address', 'testcase_ref']
        fields = []
        for f in fields_to_translate:
            try:
                fields.append({
                    'type': 'p',
                    'value': '%s: %s' % (f, getattr(message, f))
                })
            except AttributeError as ae:
                logger.debug(ae)

        fields.append({
            'type': 'p',
            'value': '%s' %
                     tabulate(
                         translate_ioppytest_description_format_to_tabulate(message.step_info),
                         tablefmt="grid")
        })

        return MsgUiDisplayMarkdownText(
            title="Please execute the %s STEP: %s" % (message.step_type, message.step_id),
            level='info',
            fields=fields
        )

    def _echo_testing_tool_configured(self, message):
        """
        {
            "_api_version": "1.0.8",
            "content_type": "application/json",
            "description": "Testing tool CONFIGURED",
            "message_id": "9cc3ab2e-0844-4203-8106-3d66fd7d9d51",
            "session_id": "41c315b3-1ae9-4369-af9d-2e877a8bd734",
            "tc_list": [
                {
                    "notes": null,
                    "objective": "AE retrieves the CSEBase resource",
                    "pre_conditions": [
                        "CSEBase resource has been automatically created in CSE"
                    ],
                    "state": null,
                    "testcase_id": "TD_M2M_NH_01",
                    "testcase_ref": "http://doc.f-interop.eu/tests/TD_M2M_NH_01"
                },
                {
                    "notes": null,
                    "objective": "AE registers to its regisrar CSE via an AE Create Request",
                    "pre_conditions": [
                        "CSEBase resource has been created in CSE with name {CSEBaseName}",
                        "AE does not have an AE-ID, i.e it registers from scratch"
                    ],
                    "state": null,
                    "testcase_id": "TD_M2M_NH_06",
                    "testcase_ref": "http://doc.f-interop.eu/tests/TD_M2M_NH_06"
                },
                {
                    "notes": null,
                    "objective": "AE retrieves <AE> resource via an AE Retrieve Request",
                    "pre_conditions": [
                        "CSEBase resource has been created in registrar CSE with name {CSEBaseName}",
                        "AE has created a <AE> resource on registrar CSE with name {AE}"
                    ],
                    "state": null,
                    "testcase_id": "TD_M2M_NH_07",
                    "testcase_ref": "http://doc.f-interop.eu/tests/TD_M2M_NH_07"
                },
        {
        """

        fields_to_translate = ['testcase_id',
                               'objective',
                               'testcase_ref',
                               'pre_conditions',
                               'notes',
                               'state',
                               ]
        fields = []

        # 'state' gets special treatment
        fields_to_translate.remove('state')

        for f in message.tc_list:
            table = []
            if type(f) is dict:
                # 'state' gets special treatment
                state = f.pop('state') if 'state' in f else "Not yet executed."

                for field_name in fields_to_translate:
                    f_value = f[field_name]
                    table.append((field_name, f_value if type(f_value) is str else list_to_str(f_value)))

                # 'state' gets special treatment
                table.append(('state', state))

            fields.append({
                'type': 'p',
                'value': '%s' % (tabulate(table, tablefmt="grid"))
            })
            fields.append({
                'type': 'p',
                'value': '---\n'
            })

        return MsgUiDisplayMarkdownText(
            title=message.description,
            level='info',
            fields=fields,
            tags={"testsuite": ""}
        )

    def _echo_testcases_list(self, message):
        """
        {
            "_api_version": "1.0.8",
            "ok": true,
            "tc_list": [
                {
                    "state": null,
                    "testcase_id": "TD_M2M_NH_01",
                    "testcase_ref": "http://doc.f-interop.eu/tests/TD_M2M_NH_01"
                },
                {
                    "state": null,
                    "testcase_id": "TD_M2M_NH_06",
                    "testcase_ref": "http://doc.f-interop.eu/tests/TD_M2M_NH_06"
                },
                ...
                ]
        }

        """

        fields_to_translate = ['testcase_id',
                               'testcase_ref',
                               'state',
                               ]
        fields = []
        table = []

        table.append(fields_to_translate)
        for f in message.tc_list:
            if type(f) is dict:
                table.append(
                    [
                        f['testcase_id'],
                        f['testcase_ref'],
                        f['state'] if f['state'] else "Not yet executed.",

                    ]
                )

        fields.append({
            'type': 'p',
            'value': '%s' % (tabulate(table, tablefmt="grid", headers="firstrow"))
        })

        return MsgUiDisplayMarkdownText(
            title="Test cases list:",
            level='info',
            fields=fields,
            tags={"testsuite": ""}
        )

    def _echo_testcase_ready(self, message):

        """
        {
            "_api_version": "1.0.8",
            "address_adn": "bbbb::1",
            "address_cse": "bbbb::2",
            "addressing_table": {
                "adn": [
                    "bbbb",
                    1
                ],
                "cse": [
                    "bbbb",
                    2
                ]
            },
            "configuration_id": "M2M_CFG_01",
            "configuration_ref": "www.onem2m.org",
            "description": "Next test case to be executed is TD_M2M_NH_06",
            "nodes": [
                "adn",
                "cse"
            ],
            "objective": "Perform GET transaction(CON mode)",
            "state": "configuring",
            "testcase_id": "TD_M2M_NH_06",
            "testcase_ref": "http://doc.f-interop.eu/tests/TD_M2M_NH_06",
            "topology": [
                {
                    "capture_filter": "udp",
                    "link_id": "link_01",
                    "nodes": [
                        "adn",
                        "cse"
                    ]
                }
            ]
        }

        """

        fields_to_translate = ['testcase_id',
                               'testcase_ref',
                               'configuration_id',
                               'configuration_ref',
                               'objective',
                               'nodes',
                               'topology',
                               ]
        fields = []
        table = []
        for f in fields_to_translate:
            try:
                value = getattr(message, f)
                # avoids having very long messages in the table
                filtered_value = textwrap.fill(value, width=STDOUT_MAX_STRING_LENGTH_VALUE_COLUMN)
                table.append((f, filtered_value))
            except AttributeError as ae:
                logger.error(ae)

        fields.append({
            'type': 'p',
            'value': '%s' % (tabulate(table, tablefmt="grid"))
        })

        return MsgUiDisplayMarkdownText(
            title=message.description,
            level='info',
            fields=fields,
            tags={"testcase": message.testcase_id}
        )

    def _echo_testcase_configure(self, message):
        """
            {
                "_api_version": "1.0.8",
                "configuration_id": "M2M_CFG_01",
                "content_type": "application/json",
                "description": [
                    "CoAP servers running service at [bbbb::2]:5683"
                ],
                "message_id": "a3d7038a-8413-464d-99d4-8da80153a863",
                "node": "cse",
                "state": "configuring",
                "testcase_id": "TD_M2M_NH_01",
                "testcase_ref": "http://doc.f-interop.eu/tests/TD_M2M_NH_01",
                "timestamp": 1517033788
            }
        """

        fields_to_translate = ['testcase_id', 'testcase_ref', 'node', 'state']
        fields = []
        for f in fields_to_translate:
            try:
                fields.append({
                    'type': 'p',
                    'value': '%s: %s' % (f, getattr(message, f))
                })
            except AttributeError as ae:
                logger.error(ae)

        fields.append({
            'type': 'p',
            'value': '%s' %
                     (tabulate(
                         translate_ioppytest_description_format_to_tabulate(message.description),
                         tablefmt="grid"))
        })

        return MsgUiDisplayMarkdownText(
            title="Please configure the IUT as indicated",
            level='info',
            fields=fields
        )

    def _echo_packet_dissected(self, message):
        """
            "_type": "dissection.autotriggered",
             "token": "0lzzb_Bx30u8Gu-xkt1DFE1GmB4",
            "frames": _frames_example,
            "testcase_id": "TBD",
            "testcase_ref": "TBD"

            format of frame list

            _frames_example = [
                {
                    "_type": "frame",
                    "id": 1,
                    "timestamp": 1464858393.547275,
                    "error": None,
                    "protocol_stack": [
                        {
                             "_type": "protocol",
                             "_protocol": "NullLoopback",
                            "AddressFamily": "2",
                            "ProtocolFamily": "0"
                        },
                        {
                            "_type": "protocol",
                            "_protocol": "IPv4",
                            "Version": "4",
                            "HeaderLength": "5",
                            "TypeOfService": "0x00",
                            "TotalLength": "41",
                            "Identification": "0x71ac",
                            "Reserved": "0",
                            "DontFragment": "0",
                            "MoreFragments": "0",
                            "FragmentOffset": "0",
                            "TimeToLive": "64",
                            "Protocol": "17",
                            "HeaderChecksum": "0x0000",
                            "SourceAddress": "127.0.0.1",
                            "DestinationAddress": "127.0.0.1",
                            "Options": "b''"
                        }
                ]
            },
        ]
        """

        fields = []
        frames_as_list_of_strings = message.frames_simple_text
        for frame_dict in message.frames:
            frame_header = []
            try:

                attribute_name = 'timestamp'
                attribute_value = datetime.datetime.fromtimestamp(int(frame_dict[attribute_name])).strftime(
                    '%Y-%m-%d %H:%M:%S')
                frame_header.append([attribute_name, attribute_value])

                for attribute_name in ['id', 'error']:
                    frame_header.append([attribute_name, frame_dict[attribute_name]])

            except KeyError as ae:
                logger.error("Some attribute was not found: %s" % str(frame_dict))
            try:
                fields.append({
                    'type': 'p',
                    'value': '-' * 70
                })
                fields.append({
                    'type': 'p',
                    'value': 'Frame header:\n%s' % tabulate(frame_header)
                })

                # for protocol_layer_dict in frame_dict['protocol_stack']:
                #     fields.append({
                #         'type': 'p',
                #         'value': 'Frame header:\n%s' % tabulate(frame_header)
                #     })
                #
                #     try:
                #         for protocol_layer_dict in frame_dict['protocol_stack']:
                #             fields.append({
                #                 'type': 'p',
                #                 'value': '%s:%s\n%s' % (
                #                     protocol_layer_dict.pop('_protocol') if '_protocol' in protocol_layer_dict else 'misc',
                #                     tabulate(protocol_layer_dict.items())
                #                 )
                #             })

                fields.append({
                    'type': 'p',
                    'value': '\n%s\n' % frames_as_list_of_strings.pop(0)
                })
            except KeyError as ae:
                logger.error("Some attrubute was not found in protocol stack dict: %s" % str(frame_dict))

        return MsgUiDisplayMarkdownText(
            level='info',
            tags={"packets": ""},
            fields=fields,
        )

    def _echo_packet_raw(self, message):
        fields = []

        dir = []
        if 'fromAgent' in message.routing_key:
            dir = 'AGENT -> TESTING TOOL'
        elif 'toAgent' in message.routing_key:
            dir = 'TESTING TOOL -> AGENT'

        fields.append({
            'type': 'p',
            'value': '%s: %s' % ('data packet', dir)
        })

        fields.append({
            'type': 'p',
            'value': '%s:%s' % ('timestamp', message.timestamp)
        })
        fields.append({
            'type': 'p',
            'value': '%s:%s' % ('interface', message.interface_name)
        })

        network_bytes_aligned = ''
        count = 0
        for int_value in message.data:
            network_bytes_aligned += format(int_value, '02x')
            if count == 7:
                network_bytes_aligned += ' \t'
                count += 1
            if count == 15:
                network_bytes_aligned += ' \n'
                count = 0
            else:
                network_bytes_aligned += ' '
                count += 1

        fields.append({
            'type': 'p',
            'value': '\n%s' % (network_bytes_aligned)
        })

        return MsgUiDisplayMarkdownText(
            level='info',
            tags={"packets": ""},
            fields=fields,
        )

    def _echo_session_configuration(self, message):
        fields = []

        fields.append({
            'type': 'p',
            'value': '%s: %s' % ('session_id', message.session_id)
        })

        fields.append({
            'type': 'p',
            'value': '%s:%s' % ('users', message.users)
        })
        fields.append({
            'type': 'p',
            'value': '%s:%s' % ('testing_tools', message.testing_tools)
        })

        try:
            testcases = message.configuration['testsuite.testcases']
            fields.append({
                'type': 'p',
                'value': '%s:%s' % ('testcases', testcases)
            })
        except Exception as e:
            logger.warning('No testsuite.testcases in %s ' % repr(message))

        try:
            additional_session_resource = message.configuration['testsuite.additional_session_resource']
            fields.append({
                'type': 'p',
                'value': '%s:%s' % ('additional_session_resource', additional_session_resource)
            })
        except Exception as e:
            logger.warning("No testsuite.additional_session_resource in %s " % repr(message))

        return MsgUiDisplayMarkdownText(
            title='This is the session configuration',
            level='info',
            fields=fields)

    def _echo_as_debug_messages(self, message):

        ret_msg = self._echo_message_as_table(message)
        ret_msg.tags = {"logs": ""}
        return ret_msg


class CoAPSessionMessageTranslator(GenericBidirectonalTranslator):
    IUT_ROLES = ['coap_client', 'coap_server']

    def __init__(self):
        super().__init__()

    def _bootstrap(self, amqp_connector):
        """
        see doc of overridden method

        only the following API calls should be used from bootstrap method:
            amqp_connector.synch_request(self, request, timeout)
            amqp_connector.publish_ui_display(self, message: Message, user_id=None, level=None)
        """

        # # # Set Up the VPN between users' IUTs # # #
        # 1. user needs to export ENV VARS

        disp = MsgUiDisplay(
            tags=UI_TAG_BOOTSTRAPPING,
            fields=[{
                "type": "p",
                "value": env_vars_export
            }]
        )
        amqp_connector.publish_ui_display(
            message=disp,
            user_id='all'
        )
        req = MsgUiRequestConfirmationButton(
            title="Confirm that variables have been exported",
            tags=UI_TAG_BOOTSTRAPPING,
            fields=[{
                "name": "confirm",
                "type": "button",
                "value": True
            }, ]
        )

        try:
            resp = amqp_connector.synch_request(
                request=req,
                timeout=300,
            )
        except Exception:  # fixme import and hanlde AmqpSynchCallTimeoutError only
            pass

        # 2. user needs to config AGENT:

        agents_kickstart_help = agents_IP_tunnel_config
        agents_kickstart_help = agents_kickstart_help.replace('SomeAgentName1', self.IUT_ROLES[0])
        agents_kickstart_help = agents_kickstart_help.replace('SomeAgentName2', self.IUT_ROLES[1])

        disp = MsgUiDisplay(
            tags=UI_TAG_BOOTSTRAPPING,
            fields=[{
                "type": "p",
                "value": agents_kickstart_help
            }, ]
        )
        amqp_connector.publish_ui_display(
            message=disp,
            user_id='all'
        )

        req = MsgUiRequestConfirmationButton(
            title="Confirm that agent component is up and running",
            tags=UI_TAG_BOOTSTRAPPING,
            fields=[{
                "name": "confirm",
                "type": "button",
                "value": True
            }, ]
        )

        try:
            resp = amqp_connector.synch_request(
                request=req,
                timeout=300,
            )
        except Exception:  # fixme import and hanlde AmqpSynchCallTimeoutError only
            pass

        return True

        # 3. TODO trigger agents configuration
        # 4. TODO automate ping test from tt
        # 5. TODO ask user to ping other user's endpoint

    # # # # # # # TT Messages # # # # # # # # # # # # # #

    def _tt_message_testsuite_start(self, user_input, origin_tt_message=None):
        return MsgTestSuiteStart()

    def _tt_message_testsuite_abort(self, user_input, origin_tt_message=None):
        return MsgTestSuiteAbort()

    def _tt_message_testcase_start(self, user_input, origin_tt_message=None):
        return MsgTestCaseStart(testcase_id=self._current_tc)

    def _tt_message_testcase_restart(self, user_input, origin_tt_message=None):
        return MsgTestCaseRestart()

    def _tt_message_testcase_skip(self, user_input, origin_tt_message=None):
        return MsgTestCaseSkip(testcase_id=origin_tt_message.testcase_id)

    def _tt_message_step_verify_executed(self, user_input, origin_tt_message=None):
        logger.info("processing: %s | %s" % (user_input, type(user_input)))

        if type(user_input) is str and user_input.lower() == 'true':
            user_input = True
        elif type(user_input) is str and user_input.lower() == 'false':
            user_input = False
        elif type(user_input) is bool:
            pass
        else:
            logger.error("Couldn't process user input %s" % user_input)
            return

        return MsgStepVerifyExecuted(
            response_type="bool",
            verify_response=user_input,
            # "node"= "coap_client",
            # "node_execution_mode": "user_assisted",
        )

    def _tt_message_step_stimuli_executed(self, user_input, origin_tt_message=None):
        return MsgStepStimuliExecuted(
            node="coap_client",
            node_execution_mode="user_assisted",
        )

    # # # # # # # UI Messages # # # # # # # # # # # # # #

    def _ui_request_testsuite_start(self, message_from_tt):
        fields = [
            {
                "name": "ts_start",
                "type": "button",
                "value": True
            },
        ]
        return MsgUiRequestConfirmationButton(
            title="Do you want to start the TEST SUITE?",
            fields=fields,
            tags={"testsuite": ""})

    def _ui_request_testcase_start(self, message_from_tt):
        message_ui_request = MsgUiRequestConfirmationButton(
            title="Do you want to start the TEST CASE <%s>?" % self._current_tc
        )
        message_ui_request.fields = [
            {
                "name": "tc_start",
                "type": "button",
                "value": True
            },
            {
                "name": "tc_skip",
                "type": "button",
                "value": True
            },
        ]
        return message_ui_request

    def _ui_request_step_stimuli_executed(self, message_from_tt):
        message_ui_request = MsgUiRequestConfirmationButton(
            title="Do you confirm executing the STIMULI  <%s> ? " % self._current_step
        )
        message_ui_request.fields = [
            {
                "name": "stimuli_executed",
                "type": "button",
                "value": True
            },
        ]
        return message_ui_request

    def _ui_request_step_verification(self, message_from_tt):
        message_ui_request = MsgUiRequestConfirmationButton(
            title="Please VERIFY the information regarding the STEP  <%s>" % self._current_step
        )
        message_ui_request.fields = [
            {
                "type": "p",
                "value": "Please provide VERIFY step response"
            },
            {
                "label": "OK",
                "name": "verify_executed",
                "type": "radio",
                "value": True
            },
            {
                "label": "Not OK",
                "name": "verify_executed",
                "type": "radio",
                "value": False
            },
        ]
        return message_ui_request


class CoMISessionMessageTranslator(CoAPSessionMessageTranslator):
    IUT_ROLES = ['comi_client', 'comi_server']

    def __init__(self):
        super().__init__()


class OneM2MSessionMessageTranslator(CoAPSessionMessageTranslator):
    IUT_ROLES = ['adn', 'cse']

    def __init__(self):
        super().__init__()


class SixLoWPANSessionMessageTranslator(CoAPSessionMessageTranslator):
    IUT_ROLES = ['eut1', 'eut2']

    def __init__(self):
        super().__init__()


class DummySessionMessageTranslator(GenericBidirectonalTranslator):
    def _bootstrap(self, amqp_connector):
        import inspect

        snippets = [self.snippet_display_markdown,
                    self.snippet_request_button,
                    self.snippet_request_radio,
                    self.snippet_request_checkbox,
                    self.snippet_request_select,
                    self.snippet_request_file]

        self.basic_display("This will demonstrate the basic calls for using the UI by using the "
                           "[utils](https://gitlab.f-interop.eu/f-interop-contributors/utils) library",
                           tags={"tutorial": ""})

        for example in snippets:
            logger.info('demoing %s' % example.__name__)
            time.sleep(10)
            markdown_text = ""
            markdown_text += ("\n-----------\n")
            markdown_text += ("\n```\n")
            markdown_text += (inspect.getsource(example))
            markdown_text += ("\n```\n")
            markdown_text += ("\n-----------\n")
            self.basic_display(markdown_text, tags={"tutorial": ""})
            markdown_text2 = ("the example will executed in 10 seconds, "
                              "you can navigate through the tags by clicking on the timeline on the top left..")
            self.basic_display(markdown_text2, tags={"tutorial": ""})

            time.sleep(10)
            example()

    def snippet_display_markdown(self):
        """
        This snippet shows how to display a message to all users (ui.user.all.display), using the
        [utils](https://gitlab.f-interop.eu/f-interop-contributors/utils) library
        """
        # this imports are absolute, for your case these will probably change
        from ioppytest.utils.messages import MsgUiDisplayMarkdownText
        from ioppytest.utils.event_bus_utils import amqp_request, publish_message
        import pika

        AMQP_EXCHANGE = str(os.environ['AMQP_EXCHANGE'])
        AMQP_URL = str(os.environ['AMQP_URL'])
        connection = pika.BlockingConnection(pika.URLParameters(AMQP_URL))

        message = MsgUiDisplayMarkdownText(
            title="Hello world Title!",
            level='highlighted',
            tags={"snippet": "display_markdown"},
            fields=[
                {
                    'type': 'p',
                    'value': "## Hello world message using MD :)"
                }
            ]
        )
        publish_message(connection, message)

    def snippet_request_button(self):
        """
        This snippet shows how to request a confirmation to a users (any) (ui.user.any.display), using the
        [utils](https://gitlab.f-interop.eu/f-interop-contributors/utils)
        library.

        (!) This is using a synchronous approach with a timeout. Dont expect to build your whole UI doing
        syncrhonous calls tho :P

        """
        # this imports are absolute, for your case these will probably change
        from ioppytest.utils.messages import MsgUiRequestConfirmationButton
        from ioppytest.utils.event_bus_utils import amqp_request, publish_message, AmqpSynchCallTimeoutError
        import pika

        AMQP_EXCHANGE = str(os.environ['AMQP_EXCHANGE'])
        AMQP_URL = str(os.environ['AMQP_URL'])
        connection = pika.BlockingConnection(pika.URLParameters(AMQP_URL))

        ui_request = MsgUiRequestConfirmationButton(
            title="Hello world Title!",
            level='highlighted',
            tags={"snippet": "button"},
            fields=[
                {
                    "name": "confirmation_button",
                    "type": "button",
                    "value": True
                },
            ]
        )

        try:
            ui_reply = amqp_request(connection,
                                    ui_request,
                                    'dummy_component',
                                    retries=30)  # fixme change retries by timeout
        except AmqpSynchCallTimeoutError:
            self.basic_display("The message request: \n`%s`" % repr(ui_request),
                               tags={"snippet": "button"})

            self.basic_display("The message reply was never received :/ did you click on the confirmation button?",
                               tags={"snippet": "button"})
            return

        self.basic_display("The message request: \n`%s`" % repr(ui_request),
                           tags={"snippet": "button"})
        self.basic_display("The message reply: \n`%s`" % repr(ui_reply),
                           tags={"snippet": "button"})

    def snippet_request_radio(self):
        """
        This snippet shows how to request a confirmation to a users (any) (ui.user.any.display), using the
        [utils](https://gitlab.f-interop.eu/f-interop-contributors/utils)
        library.

        (!) This is using a synchronous approach with a timeout. Dont expect to build your whole UI doing
        syncrhonous calls tho :P

        """
        # this imports are absolute, for your case these will probably change
        from ioppytest.utils.messages import MsgUiRequestConfirmationButton
        from ioppytest.utils.event_bus_utils import amqp_request, publish_message, AmqpSynchCallTimeoutError
        import pika

        AMQP_EXCHANGE = str(os.environ['AMQP_EXCHANGE'])
        AMQP_URL = str(os.environ['AMQP_URL'])
        connection = pika.BlockingConnection(pika.URLParameters(AMQP_URL))

        ui_request = MsgUiRequestQuestionRadio(
            title="This is a question",
            tags={"snippet": "radio"}
        )

        try:
            ui_reply = amqp_request(connection,
                                    ui_request,
                                    'dummy_component',
                                    retries=30)  # fixme change retries by timeout
        except AmqpSynchCallTimeoutError:
            self.basic_display("The message request: \n`%s`" % repr(ui_request),
                               tags={"snippet": "radio"})
            self.basic_display("The message reply was never received :/",
                               tags={"snippet": "radio"})
            return

        self.basic_display("The message request: \n`%s`" % repr(ui_request),
                           tags={"snippet": "radio"})
        self.basic_display("The message reply: \n`%s`" % repr(ui_reply),
                           tags={"snippet": "radio"})

    def snippet_request_checkbox(self):
        """
        This snippet shows how to request a confirmation to a users (any) (ui.user.any.display), using the
        [utils](https://gitlab.f-interop.eu/f-interop-contributors/utils)
        library.

        (!) This is using a synchronous approach with a timeout. Dont expect to build your whole UI doing
        syncrhonous calls tho :P

        """
        # this imports are absolute, for your case these will probably change
        from ioppytest.utils.messages import MsgUiRequestConfirmationButton
        from ioppytest.utils.event_bus_utils import amqp_request, publish_message, AmqpSynchCallTimeoutError
        import pika

        AMQP_EXCHANGE = str(os.environ['AMQP_EXCHANGE'])
        AMQP_URL = str(os.environ['AMQP_URL'])
        connection = pika.BlockingConnection(pika.URLParameters(AMQP_URL))

        ui_request = MsgUiRequestQuestionCheckbox(
            title="It's a matter of choice",
            tags={"snippet": "checkbox"}
        )

        try:
            ui_reply = amqp_request(connection,
                                    ui_request,
                                    'dummy_component',
                                    retries=30)  # fixme change retries by timeout
        except AmqpSynchCallTimeoutError:
            self.basic_display("The message request: \n`%s`" % repr(ui_request),
                               tags={"snippet": "checkbox"})
            self.basic_display("The message reply was never received :/",
                               tags={"snippet": "checkbox"})
            return

        self.basic_display("The message request: \n`%s`" % repr(ui_request),
                           tags={"snippet": "checkbox"})
        self.basic_display("The message reply: \n`%s`" % repr(ui_reply),
                           tags={"snippet": "checkbox"})

    def snippet_request_select(self):
        """
        This snippet shows how to request a confirmation to a users (any) (ui.user.any.display), using the
        [utils](https://gitlab.f-interop.eu/f-interop-contributors/utils)
        library.

        (!) This is using a synchronous approach with a timeout. Dont expect to build your whole UI doing
        syncrhonous calls tho :P

        """
        # this imports are absolute, for your case these will probably change
        from ioppytest.utils.messages import MsgUiRequestConfirmationButton
        from ioppytest.utils.event_bus_utils import amqp_request, publish_message, AmqpSynchCallTimeoutError
        import pika

        AMQP_EXCHANGE = str(os.environ['AMQP_EXCHANGE'])
        AMQP_URL = str(os.environ['AMQP_URL'])
        connection = pika.BlockingConnection(pika.URLParameters(AMQP_URL))

        ui_request = MsgUiRequestQuestionSelect(
            title="It's a matter of choice",
            tags={"snippet": "select"}
        )

        try:
            ui_reply = amqp_request(connection,
                                    ui_request,
                                    'dummy_component',
                                    retries=30)  # fixme change retries by timeout
        except AmqpSynchCallTimeoutError:
            self.basic_display("The message request: \n`%s`" % repr(ui_request),
                               tags={"snippet": "select"})
            self.basic_display("The message reply was never received :/",
                               tags={"snippet": "select"})
            return

        self.basic_display("The message request: \n`%s`" % repr(ui_request),
                           tags={"snippet": "select"})
        self.basic_display("The message reply: \n`%s`" % repr(ui_reply),
                           tags={"snippet": "select"})

    def snippet_request_file(self):
        """
        This snippet shows how to request a confirmation to a users (any) (ui.user.any.display), using the
        [utils](https://gitlab.f-interop.eu/f-interop-contributors/utils)
        library.

        (!) This is using a synchronous approach with a timeout. Dont expect to build your whole UI doing
        syncrhonous calls tho :P

        """
        # this imports are absolute, for your case these will probably change
        from ioppytest.utils.messages import MsgUiRequestConfirmationButton
        from ioppytest.utils.event_bus_utils import amqp_request, publish_message, AmqpSynchCallTimeoutError
        import pika

        AMQP_EXCHANGE = str(os.environ['AMQP_EXCHANGE'])
        AMQP_URL = str(os.environ['AMQP_URL'])
        connection = pika.BlockingConnection(pika.URLParameters(AMQP_URL))

        ui_request = MsgUiRequestUploadFile(
            title="Give me your file!",
            tags={"snippet": "file"}
        )

        try:
            ui_reply = amqp_request(connection,
                                    ui_request,
                                    'dummy_component',
                                    retries=30)  # fixme change retries by timeout
        except AmqpSynchCallTimeoutError:
            self.basic_display("The message request: \n`%s`" % repr(ui_request),
                               tags={"snippet": "file_upload"})
            self.basic_display("The message reply was never received :/",
                               tags={"snippet": "file_upload"})
            return

        self.basic_display("The message request: \n`%s`" % repr(ui_request),
                           tags={"snippet": "file_upload"})
        self.basic_display("The message reply: \n`%s`" % repr(ui_reply),
                           tags={"snippet": "file_upload"})

    def basic_display(self, text: str, tags={}):
        from ioppytest.utils.messages import MsgUiDisplayMarkdownText
        from ioppytest.utils.event_bus_utils import publish_message
        import pika

        AMQP_EXCHANGE = str(os.environ['AMQP_EXCHANGE'])
        AMQP_URL = str(os.environ['AMQP_URL'])
        connection = pika.BlockingConnection(pika.URLParameters(AMQP_URL))

        message = MsgUiDisplayMarkdownText(
            tags=tags,
            fields=[
                {
                    'type': 'p',
                    'value': "%s" % text
                }
            ]
        )
        publish_message(connection, message)


__all__ = [
    GenericBidirectonalTranslator,
    CoAPSessionMessageTranslator,
    OneM2MSessionMessageTranslator,
    SixLoWPANSessionMessageTranslator,
    CoMISessionMessageTranslator
]
